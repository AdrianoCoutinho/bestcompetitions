import axios from "axios";
import { apifyEnv } from "../../envs/apify.env";

axios.defaults.baseURL = apifyEnv.secret;

export interface ApiResponse {
  ok: boolean;
  data?: any;
  message: string;
  code?: number;
  msg?: string;
}

export const getTiktokVideo = async (url: string): Promise<any> => {
  try {
    const data = {
      postURLs: [url],
      resultsPerPage: 1,
      shouldDownloadCovers: false,
      shouldDownloadSlideshowImages: false,
      shouldDownloadSubtitles: false,
      shouldDownloadVideos: false,
    };

    const result = await axios.post(
      `/clockworks~free-tiktok-scraper/run-sync-get-dataset-items?token=apify_api_fHW6ZChzJXbsB4KeVlGKx8zeSINPj50enqIS`,
      data
    );

    if (result.data[0].error === "Post not found or private.") {
      return null;
    }

    return result.data;
  } catch (error: any) {
    if (error.request?.response) {
      const result = error.request.response;
      return JSON.parse(result);
    }

    return {
      ok: false,
      message: error.toString(),
    };
  }
};

export const getInstagramReelsVideo = async (url: string): Promise<any> => {
  try {
    const data = {
      addParentData: false,
      directUrls: [url],
      enhanceUserSearchWithFacebookPage: false,
      isUserTaggedFeedURL: false,
      resultsLimit: 200,
      resultsType: "posts",
      searchLimit: 1,
      searchType: "hashtag",
    };
    const result = await axios.post(
      `/apify~instagram-scraper/run-sync-get-dataset-items?token=apify_api_fHW6ZChzJXbsB4KeVlGKx8zeSINPj50enqIS`,
      data
    );

    return result.data;
  } catch (error: any) {
    if (error.request?.response) {
      const result = error.request.response;
      return JSON.parse(result);
    }

    return {
      ok: false,
      message: error.toString(),
    };
  }
};

export const getYoutubeShortVideo = async (url: string): Promise<any> => {
  try {
    const data = {
      downloadSubtitles: false,
      hasCC: false,
      hasLocation: false,
      hasSubtitles: false,
      is360: false,
      is3D: false,
      is4K: false,
      isBought: false,
      isHD: false,
      isHDR: false,
      isLive: false,
      isVR180: false,
      maxResultStreams: 0,
      maxResults: 1,
      maxResultsShorts: 0,
      preferAutoGeneratedSubtitles: false,
      saveSubsToKVS: false,
      startUrls: [
        {
          url: url,
        },
      ],
    };
    const result = await axios.post(
      `/streamers~youtube-scraper/run-sync-get-dataset-items?token=apify_api_fHW6ZChzJXbsB4KeVlGKx8zeSINPj50enqIS`,
      data
    );

    return result.data;
  } catch (error: any) {
    if (error.request?.response) {
      const result = error.request.response;
      return JSON.parse(result);
    }

    return {
      ok: false,
      message: error.toString(),
    };
  }
};

export const verifyTiktokUser = async (url: string): Promise<any> => {
  try {
    const data = {
      postURLs: [url],
      resultsPerPage: 1,
      shouldDownloadCovers: false,
      shouldDownloadSlideshowImages: false,
      shouldDownloadSubtitles: false,
      shouldDownloadVideos: false,
    };
    const result = await axios.post("", data);
    return result.data;
  } catch (error: any) {
    if (error.request?.response) {
      const result = error.request.response;
      return JSON.parse(result);
    }

    return {
      ok: false,
      message: error.toString(),
    };
  }
};

export const getView = async (url: string): Promise<any> => {
  try {
    const data = {
      postURLs: [url],
      resultsPerPage: 1,
      shouldDownloadCovers: false,
      shouldDownloadSlideshowImages: false,
      shouldDownloadSubtitles: false,
      shouldDownloadVideos: false,
    };
    const result = await axios.post("", data);
    if (result.data[0].error) {
      return {
        ok: false,
        message: "Video n√£o encontrado!",
        data: [{ diggCount: -1, shareCount: -1, playCount: -1 }],
      };
    } else {
      return {
        ok: true,
        message: "Video carregado com sucesso!",
        data: result.data,
      };
    }
  } catch (error: any) {
    if (error.request?.response) {
      const result = error.request.response;
      return JSON.parse(result);
    }

    return {
      ok: false,
      message: error.toString(),
    };
  }
};
